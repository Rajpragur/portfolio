I"ú{<h1 id="construindo-fun√ß√µes-atrav√©s-de-lambda">Construindo Fun√ß√µes Atrav√©s de <em>Lambda</em></h1>

<p>Como visto na fun√ß√£o <code class="language-plaintext highlighter-rouge">sum</code> , parece estranho termos que definir procedimentos t√£o triviais como <code class="language-plaintext highlighter-rouge">pi-term</code> ou <code class="language-plaintext highlighter-rouge">pi-next</code> apenas para que possamos us√°-los como argumentos na fun√ß√£o (<em>procedure</em>) de alta ordem. Ao inv√©s de definirmos esses termos, seria mais conveniente de especifica-los diretamente, digamos, sem precisar ‚Äúbatiz√°-los‚Äù com algum nome. Podemos fazer isso atrav√©s do conceito de <em>Lambda.</em></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="mf">1.0</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))))</span>
</code></pre></div></div>

<p>Nossa fun√ß√£o <code class="language-plaintext highlighter-rouge">pi-sum</code> pode ser expressa agora sem precisar de nenhuma defini√ß√£o de fun√ß√µes auxiliares, observe:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pi-sum</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="mf">1.0</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))))</span>
       <span class="nv">a</span>
       <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">4</span><span class="p">))</span>
       <span class="nv">b</span><span class="p">))</span>
</code></pre></div></div>

<p>Novamente, usando <em>lambda</em>, n√≥s podemos escrever a fun√ß√£o de <code class="language-plaintext highlighter-rouge">integral</code> da seguinte forma:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">integral</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">dx</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">dx</span> <span class="mf">2.0</span><span class="p">))</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">dx</span><span class="p">))</span>
            <span class="nv">b</span><span class="p">)</span>
     <span class="nv">dx</span><span class="p">))</span>
</code></pre></div></div>

<p>Em geral, <em>lambda</em> √© usado para criar fun√ß√µes da mesma maneira que cri√°vamos com o <code class="language-plaintext highlighter-rouge">define</code>, por√©m agora sem o nome que antes servia como identifica√ß√£o da mesma. Confira a f√≥rmula geral de uma fun√ß√£o <em>lambda</em>:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="err">‚ü®</span><span class="nv">formal-parameters</span><span class="err">‚ü©</span><span class="p">)</span> <span class="err">‚ü®</span><span class="nv">body</span><span class="err">‚ü©</span><span class="p">)</span>
</code></pre></div></div>
<h2 id="usando-let-para-criar-vari√°veis-locais">Usando <em>let</em> Para Criar Vari√°veis Locais</h2>

<p>Outra utilidade do conceito de lambda √© poder criar vari√°veis locais. Frequentemente precisamos de vari√°veis locais em fun√ß√µes al√©m daquelas j√° passadas nos par√¢metros formais. Imagine o seguinte exemplo:</p>

\[f(x,y) = x(1+xy)^2 + y(1-y) +(1+xy)(1-y),\]

<p>Essa mesma fun√ß√£o poderia tamb√©m ser escrita da seguinte maneira:</p>

\[a = 1 + xy, \\
b = 1 -y, \\
f(x,y) = xa^2 + yb + ab.\]

<p>No processo de escrita de uma fun√ß√£o que compute $f$, n√≥s gostar√≠amos de poder incluir as vari√°veis locais necess√°rias, n√£o apenas $x$ e $y$, mas tamb√©m as intermediarias como $a$ e $b$. Uma forma de se resolver isso seria atrav√©s do uso de fun√ß√µes auxiliares que vinculam as vari√°veis locais.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f-helper</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">a</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">*</span> <span class="nv">y</span> <span class="nv">b</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">f-helper</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> 
            <span class="p">(</span><span class="nb">-</span> <span class="mi">1</span> <span class="nv">y</span><span class="p">)))</span>
</code></pre></div></div>

<p>Por√©m como vimos o conceito de <em>lambda</em> e como ele pode facilitar muito de nossa vida na programa√ß√£o, vamos refazer esta fun√ß√£o acima com o uso do seu conceito:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">a</span><span class="p">))</span> 
        <span class="p">(</span><span class="nb">*</span> <span class="nv">y</span> <span class="nv">b</span><span class="p">)</span> 
        <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
   <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
   <span class="p">(</span><span class="nb">-</span> <span class="mi">1</span> <span class="nv">y</span><span class="p">)))</span>
</code></pre></div></div>

<p>Por√©m gra√ßas a utilidade desta constru√ß√£o, podemos usar uma forma especial (<em>special form</em>) ainda mais conveniente para nos ajudar, o <code class="language-plaintext highlighter-rouge">let</code></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">1</span> <span class="nv">y</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">a</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">*</span> <span class="nv">y</span> <span class="nv">b</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>
</code></pre></div></div>

<p>A forma geral da express√£o <code class="language-plaintext highlighter-rouge">let</code> pode ser vista da seguinte maneira:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="err">‚ü®</span><span class="nv">var</span><span class="err">‚ÇÅ‚ü©</span> <span class="err">‚ü®</span><span class="nv">exp</span><span class="err">‚ÇÅ‚ü©</span><span class="p">)</span>
      <span class="p">(</span><span class="err">‚ü®</span><span class="nv">var</span><span class="err">‚ÇÇ‚ü©</span> <span class="err">‚ü®</span><span class="nv">exp</span><span class="err">‚ÇÇ‚ü©</span><span class="p">)</span>
      <span class="err">‚Ä¶</span>
      <span class="p">(</span><span class="err">‚ü®</span><span class="nv">var</span><span class="err">‚Çô‚ü©</span> <span class="err">‚ü®</span><span class="nv">exp</span><span class="err">‚Çô‚ü©</span><span class="p">))</span>
  <span class="err">‚ü®</span><span class="nv">body</span><span class="err">‚ü©</span><span class="p">)</span>
</code></pre></div></div>

<p>E pode ser ‚Äúlida‚Äù da seguinte forma:</p>

<p>let  ‚ü®var‚ÇÅ‚ü© have the value ‚ü®exp‚ÇÅ‚ü© and
      ‚ü®var‚ÇÇ‚ü© have the value ‚ü®exp‚ÇÇ‚ü© and
    ‚Ä¶
      ‚ü®var‚Çô‚ü© have the value ‚ü®exp‚Çô‚ü©
  in ‚ü®body‚ü©</p>

<p>A primeira parte da express√£o <code class="language-plaintext highlighter-rouge">let</code> √© uma lista de pares de nome de express√µes (name-expression).Quando o <code class="language-plaintext highlighter-rouge">let</code> √© avaliado, cada nome √© associado a um valor correspondente na express√£o. O corpo da express√£o <code class="language-plaintext highlighter-rouge">let</code> tem esses nomes vinculados a vari√°veis locais. A forma como tudo isto acontece √© que a express√£o <code class="language-plaintext highlighter-rouge">let</code> √© interpretada como uma sintaxe alternativa para:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="err">‚ü®</span><span class="nv">var</span><span class="err">‚ÇÅ‚ü©</span> <span class="err">‚Ä¶</span> <span class="err">‚ü®</span><span class="nv">var</span><span class="err">‚Çô‚ü©</span><span class="p">)</span>
   <span class="err">‚ü®</span><span class="nv">body</span><span class="err">‚ü©</span><span class="p">)</span>
 <span class="err">‚ü®</span><span class="nv">exp</span><span class="err">‚ÇÅ‚ü©</span>
 <span class="err">‚Ä¶</span>
 <span class="err">‚ü®</span><span class="nv">exp</span><span class="err">‚Çô‚ü©</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="exerc√≠cios">Exerc√≠cios</h2>

<blockquote>
  <p><strong>Exercise 1.34</strong>: Suppose we define the procedure:</p>
</blockquote>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">g</span><span class="p">)</span> <span class="p">(</span><span class="nf">g</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<blockquote>
  <p>Then we have</p>
</blockquote>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">f</span> <span class="nv">square</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="mi">4</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">z</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">z</span> <span class="mi">1</span><span class="p">))))</span>
<span class="nv">&gt;</span> <span class="mi">6</span>
</code></pre></div></div>

<blockquote>
  <p>What happens if we (perversely) ask the interpreter to evaluate the combination (f f)? Explain.</p>
</blockquote>

<ul>
  <li>
    <p><strong>Resposta</strong></p>

    <p>A fun√ß√£o f recebe como argumento uma outra fun√ß√£o, logo quando a fun√ß√£o f passada for chamada, ir√° resultar em um erro pois 2 √© um n√∫mero e n√£o uma fun√ß√£o</p>
  </li>
</ul>

<hr />

<h2 id="fun√ß√µes-como-m√©todos-gerais">Fun√ß√µes como M√©todos Gerais</h2>

<p>Foi introduzido anteriormente o conceito de <strong>fun√ß√µes compostas</strong> como um mecanismo para abstrair padr√µes de opera√ß√µes num√©ricas de moo a torn√°-los independentes, ou seja, independente  do n√∫mero particular envolvido na opera√ß√£o, funcionando de forma geral</p>

<p>Com as fun√ß√µes de ordem superior (fun√ß√£o de integral), podemos observar um tipo mais poderoso de abstra√ß√£o: fun√ß√µes usadas para expressar m√©todos gerais de computa√ß√£o, independente das fun√ß√µes particulares envolvidas.</p>

<p>Nesta se√ß√£o ser√° discutido dois exemplos mais elaborados:</p>

<ul>
  <li><strong>M√©todos Gerais</strong> para encontrar zeros e pontos fixos de fun√ß√µes</li>
  <li>Como expressar diretamente esses m√©todos em forma de fun√ß√£o</li>
</ul>

<h3 id="encontrar-ra√≠zes-de-equa√ß√µes-atrav√©s-do-m√©todo-de-bissec√ß√£o">Encontrar Ra√≠zes de Equa√ß√µes atrav√©s do m√©todo de bissec√ß√£o</h3>

<p>O m√©todo de bissec√ß√£o √© uma t√©cnica simples, por√©m poderosa. Com ela √© poss√≠vel encontrarmos as ra√≠zes de uma equa√ß√£o $f(x) = 0$, onde $f$ √© uma <strong>fun√ß√£o cont√≠nua.</strong> A ideia √© esta, se nos for dado os pontos $a$ e $b$ em que $f(a) &lt;0&lt;f(b)$, ent√£o $f$ deve ter pelo menos um valor $0$ entre $a$ e $b$.</p>

<p>Para localizar o valor zero, seja $x$ a m√©dia de $a$ e $b$ , ent√£o compute $f(x)$. Caso $f(x) &lt;0$, ent√£o   $f$ deve ter um valor zero entre $x$ e $b$. Continuando, podemos identificar intervalos cada vez menores nos quais $f$ deve ter um valor zero. Quando chegarmos a um ponto em que o intervalo √© pequeno o suficiente, o processo acaba.</p>

<p>Uma vez que o intervalo de incerteza √© reduzido pela metade em cada etapa do processo, o n√∫mero de etapas necess√°rias cresce como $Œò(log(L/T))$, onde $L$ √© o comprimento do intervalo original e $T$ √© o erro de toler√¢ncia(ou seja, o tamanho do intervalo que consideraremos ‚Äúsuficientemente pequeno‚Äù).</p>

<p>Aqui est√° uma fun√ß√£o que implementa esta estrat√©gia:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">search</span> <span class="nv">f</span> <span class="nv">neg-point</span> <span class="nv">pos-point</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">midpoint</span> 
         <span class="p">(</span><span class="nf">average</span> <span class="nv">neg-point</span> <span class="nv">pos-point</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">close-enough?</span> <span class="nv">neg-point</span> <span class="nv">pos-point</span><span class="p">)</span>
        <span class="nv">midpoint</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">test-value</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">midpoint</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">cond</span> 
           <span class="p">((</span><span class="nb">positive?</span> <span class="nv">test-value</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">search</span> <span class="nv">f</span> <span class="nv">neg-point</span> <span class="nv">midpoint</span><span class="p">))</span>
           <span class="p">((</span><span class="nb">negative?</span> <span class="nv">test-value</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">search</span> <span class="nv">f</span> <span class="nv">midpoint</span> <span class="nv">pos-point</span><span class="p">))</span>
           <span class="p">(</span><span class="k">else</span> <span class="nv">midpoint</span><span class="p">))))))</span>
</code></pre></div></div>

<p>Assumimos que inicialmente recebemos a fun√ß√£o $f$ junto com os pontos nos quais seus valores s√£o negativos e positivos. Primeiro calculamos o ponto m√©dio dos dois pontos dados, em seguida verificamos se o intervalo dado √© pequeno o suficiente e, se for, simplesmente retornamos o ponto m√©dio como nossa resposta. Caso o contr√°rio, calculamos como um valor de teste o valor de $f$ no ponto m√©dio.</p>

<p>Se o valor do teste for positivo, ent√£o continuamos o processo com um novo intervalo que vai do ponto negativo original ao ponto m√©dio. Se o valor do teste for negativo, continuamos com o intervalor do ponto m√©dio ao ponto positivo.</p>

<p>Finalmente, existe a possibilidade do valor do teste ser $0$, caso em que o ponto m√©dio √© a pr√≥pria raiz que procur√°vamos.</p>

<p>Para testar se os pontos finais est√£o ‚Äúpr√≥ximos o suficiente‚Äù, podemos usar a seguinte fun√ß√£o:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">close-enough?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> 
  <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">abs</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="mf">0.001</span><span class="p">))</span>
</code></pre></div></div>

<p>Usar a fun√ß√£o <code class="language-plaintext highlighter-rouge">Search</code> n√£o √© uma boa escolha, pois acidentalmente podemos dar a ela pontos em que os valores de $f$ n√£o tem o sinal necess√°rio, nesse caso obter√≠amos uma resposta errada. Em vez disso, usaremos a pesquisa por meio da seguinte fun√ß√£o, que verifica qual dos pontos de extremidade tem um valor de fun√ß√£o negativo e qual tem um valor positivo e, chama o procedimento de pesquisa de acordo com o valor obtido.</p>

<p>Se a fun√ß√£o tiver o mesmo sinal nos dois pontos dados, o m√©todo do intervalo n√£o pode ser usado, caso em que a fun√ß√£o sinaliza um erro.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">half-interval-method</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">a-value</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">b-value</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">b</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="k">and</span> <span class="p">(</span><span class="nb">negative?</span> <span class="nv">a-value</span><span class="p">)</span> 
                <span class="p">(</span><span class="nb">positive?</span> <span class="nv">b-value</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">search</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
          <span class="p">((</span><span class="k">and</span> <span class="p">(</span><span class="nb">negative?</span> <span class="nv">b-value</span><span class="p">)</span> 
                <span class="p">(</span><span class="nb">positive?</span> <span class="nv">a-value</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">search</span> <span class="nv">f</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">))</span>
          <span class="p">(</span><span class="k">else</span>
           <span class="p">(</span><span class="nf">error</span> <span class="s">"Values are not of 
                   opposite sign"</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))))</span>
</code></pre></div></div>

<p>O exemplo a seguir usa o m√©todo de bissec√ß√£o para aproximar $\pi$ como raiz entre $2$ e $4$ de $\sin x=0$:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">half-interval-method</span> <span class="nv">sin</span> <span class="mf">2.0</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="mf">3.14111328125</span>
</code></pre></div></div>

<p>Outro exemplo, agora com a equa√ß√£o $x^3-2x-3=0$ entre $1$ e  $2$:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">half-interval-method</span> 
 <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
 <span class="mf">1.0</span>
 <span class="mf">2.0</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="mf">1.89306640625</span>
</code></pre></div></div>

<h3 id="encontrando-pontos-fixos-das-fun√ß√µes">Encontrando Pontos Fixos Das Fun√ß√µes</h3>

<p>Um n√∫mero $x$ √© chamado de ponto fixo de uma fun√ß√£o quando $x$ satisfaz a equa√ß√£o $f(x) = x$. Para algumas fun√ß√µes $f$, podemos localizar um ponto fixo come√ßando com uma estimativa inicial e aplicando $f$ repetidamente at√© que o valor n√£o mude muito</p>

\[f(x),f(f(x)),f(f(f(x))),...\]

<p>Usando est√° ideia, podemos conceber uma fun√ß√£o de ponto fixo que toma como entradas uma fun√ß√£o e uma estimativa inicial e produz uma aproxima√ß√£o de um ponto fixo da fun√ß√£o.</p>

<p>Aplicamos a fun√ß√£o repetidamente at√© encontrarmos dois valores sucessivos cuja diferen√ßa √© menor do que alguma toler√¢ncia prescrita:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">tolerance</span> <span class="mf">0.00001</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fixed-point</span> <span class="nv">f</span> <span class="nv">first-guess</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">close-enough?</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">abs</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">))</span> 
       <span class="nv">tolerance</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">try</span> <span class="nv">guess</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">next</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">guess</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">close-enough?</span> <span class="nv">guess</span> <span class="nv">next</span><span class="p">)</span>
          <span class="nv">next</span>
          <span class="p">(</span><span class="nf">try</span> <span class="nv">next</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">try</span> <span class="nv">first-guess</span><span class="p">))</span>
</code></pre></div></div>

<p>Por exemplo, n√≥s podemos usar este m√©todo para aproximar o ponto fixo da fun√ß√£o cosseno, come√ßando com $1$ como estimativa inicial:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">fixed-point</span> <span class="nv">cos</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="o">.</span><span class="mi">7390822985224023</span>
</code></pre></div></div>

<p>Vejamos agora como outro exemplo, a solu√ß√£o da equa√ß√£o $y = \sin y + \cos y$ :</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">fixed-point</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">sin</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">cos</span> <span class="nv">y</span><span class="p">)))</span>
             <span class="mf">1.0</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="mf">1.2587315962971173</span>
</code></pre></div></div>

<p>O processo de ponto fixo √© uma reminisc√™ncia do processo que usamos para encontrar ra√≠zes quadradas, ambos s√£o baseados na ideia de melhorar repetidamente uma estimativa at√© que o resultado satisfa√ßa algum crit√©rio. Na verdade podemos formular prontamente o c√°lculo da raiz quadrada assim como a pesquisa de ponto fixo.</p>

<p>Calcular a raiz quadrada de algum n√∫mero $x$ requer encontrar um $y$ tal que $y^2 = x$. Colocando est√° equa√ß√£o na forma equivalente $y = \frac {x}{x}$, n√≥s reconhecemos que estamos procurando um ponto fixo da fun√ß√£o $y \mapsto \frac{x}{y}$, e podemos portanto, tentar calcular as raizes quadradas da seguinte forma:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fixed-point</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
               <span class="mf">1.0</span><span class="p">))</span>
</code></pre></div></div>

<p>Infelizmente, essa busca de ponto fixo n√£o converge. Considere uma estimativa inicial $y_{1}$, a pr√≥xima estimativa √© $y_{2} = \frac{x}{y_{1}}$ e a pr√≥xima ser√° $y_{3} = \frac{x}{y_{2}} = \frac{x}{(\frac{x}{y_{1}})}$. Isto resulta em loop infinito no qual as duas suposi√ß√µes $y_{1}$ e  $y_{2}$ se repetem continuamente, oscilando em torno da resposta.</p>

<p>Uma maneira de controlar estas oscila√ß√µes √© evitar que as suposi√ß√µes mudem tanto. Uma vez que a resposta est√° sempre entre nosso palpite $y$ e $\frac {x}{y}$, podemos fazer um novo palpite que n√£o est√° t√£o longe desses dois valores. Podemos fazer isto calculando a m√©dia de $y$ com $\frac {x}{y}$, de modo que o pr√≥ximo palpite depois de $y$ seja $\frac{1}{2}(y+\frac{x}{y})$ ao inv√©s de somente $\frac {x}{y}$. O processo de fazer tal sequencia de palpites √© simplesmente o processo de olhar para um ponto fixo de $y \mapsto \frac{1}{2} (y+\frac{x}{y})$:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fixed-point</span> 
   <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">average</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
   <span class="mf">1.0</span><span class="p">))</span>
</code></pre></div></div>

<p>Com essa modifica√ß√£o, a fun√ß√£o de raiz quadrada funciona. Na verdade, se desvendarmos as defini√ß√µes, podemos ver que a sequ√™ncia de aproxima√ß√µes da raiz quadrada gerada √© precisamente a mesma gerada pela nossa fun√ß√£o anterior.</p>

<p>Essa abordagem de calcular a m√©dia de aproxima√ß√µes sucessivas de uma solu√ß√£o, uma t√©cnica que chamamos de <em>average damping</em>, muitas vezes auxilia na converg√™ncia de pesquisas de ponto fixo.</p>
:ET