I"ˆX<h1 id="o-que-significa-dados">O que significa ‚ÄúDados‚Äù?</h1>

<p>N√≥s come√ßamos a implementa√ß√£o dos n√∫meros racionais nos exemplos anteriores atrav√©s da implementa√ß√£o das fun√ß√µes <code class="language-plaintext highlighter-rouge">add-rat</code>, <code class="language-plaintext highlighter-rouge">sub-rat</code> e tamb√©m atrav√©s de outras tr√™s fun√ß√µes n√£o especificadas: <code class="language-plaintext highlighter-rouge">make-rat</code>, <code class="language-plaintext highlighter-rouge">numer</code> e <code class="language-plaintext highlighter-rouge">denom</code>. At√© esse ponto, n√≥s podemos pensar nas opera√ß√µes sendo definidas atrav√©s de objetos de dados (objetos numeradores, objetos denominadores e n√∫meros racionais) nos quais o comportamento vai ser especificado no futuro atrav√©s das tr√™s fun√ß√µes</p>

<p>Por√©m, o que exatamente significa ‚ÄúDados‚Äù? N√£o √© suficiente apenas dizer ‚ÄúTudo aquilo que √© implementado por determinado seletores e construtores‚Äù. Claramente, nem todo conjunto arbitr√°rio de tr√™s fun√ß√µes pode servir como uma base apropriada para se implementar n√∫meros racionais</p>

<p>N√≥s precisamos garantir isto, se caso n√≥s construirmos um n√∫mero racional $x$ a partir de um par de inteiros $n$ e $d$, ent√£o extrair o numerador e denominador de $x$ e depois dividir eles, devemos ter o mesmo resultado dividindo $n$ por $d$. Em outras palavras: <code class="language-plaintext highlighter-rouge">make-rat</code>, <code class="language-plaintext highlighter-rouge">numer</code> e <code class="language-plaintext highlighter-rouge">denom</code> devem satisfazer esta condi√ß√£o, para qualquer inteiro $n$ e para qualquer denominador (diferente de $0$) $d$, se $x$ √© igual ao retorno da fun√ß√£o (make-rat n d), ent√£o:</p>

\[\frac{(\text {numer } x )}{(\text {denom } x)} = \frac{n}{d}\]

<p>De fato, est√° √© a √∫nica condi√ß√£o necess√°ria que as fun√ß√µes precisam satisfazer para formar uma base v√°lida para a representa√ß√£o de um n√∫mero racional. De formal geral, n√≥s podemos pensar em dados como uma cole√ß√£o de seletores e construtores que quando atuam juntos s√£o capazes de preencher os requisitos para validar uma condi√ß√£o espec√≠fica</p>

<p>Essa perspectiva serve n√£o apenas para definir objetos de dados de ‚Äúalto n√≠vel‚Äù como no caso de n√∫meros racionais, mas tamb√©m objetos de dados de n√≠veis inferiores. Considere a no√ß√£o de par, que n√≥s usamos para definir nossos n√∫meros racionais. N√≥s nunca dissemos o que um par significava, apenas que as fun√ß√µes <code class="language-plaintext highlighter-rouge">cons</code>, car e <code class="language-plaintext highlighter-rouge">cdr</code> operam sobre pares. Por√©m a √∫nica coisa que n√≥s precisamos saber a respeito dessas tr√™s opera√ß√µes √© que se n√≥s, ‚Äúcolarmos‚Äù dois objetos usando cons, n√≥s podemos retornar esses mesmos objetos atrav√©s de car e cdr.</p>

<p>Portanto, as opera√ß√µes satisfazem a condi√ß√£o de que para cada objeto $x$ e $y$, se $z$ for igual o valor de retorno da fun√ß√£o <code class="language-plaintext highlighter-rouge">(cons x y)</code>, ent√£o <code class="language-plaintext highlighter-rouge">(car z)</code> √© igual a $x$ e <code class="language-plaintext highlighter-rouge">(cdr z)</code> √© igual a $y$. De fato, n√≥s mencionamos que estas tr√™s fun√ß√µes s√£o inclu√≠das como primitivas na nossa linguagem, contudo, qualquer outras tr√™s fun√ß√µes que satisfa√ß√£o a condi√ß√£o descrita, poder√£o ser v√°lidas para implementar um par. Esse ponto √© ilustrado de maneira impressionante pelo fato de que poder√≠amos implementar <code class="language-plaintext highlighter-rouge">cons</code>, <code class="language-plaintext highlighter-rouge">car</code> e <code class="language-plaintext highlighter-rouge">cdr</code> sem usar nenhuma estrutura de dados, mas apenas usando fun√ß√µes, confira o exemplo abaixo:procedimentos</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">m</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
          <span class="p">((</span><span class="nb">=</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
          <span class="p">(</span><span class="k">else</span> 
           <span class="p">(</span><span class="nf">error</span> <span class="s">"Argument not 0 or 1:
                   CONS"</span> <span class="nv">m</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">z</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">z</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<p>Esse uso de fun√ß√µes n√£o corresponde com nada do que nossa no√ß√£o intuitiva de dados deveria ser. Mesmo assim, tudo que n√≥s precisamos fazer para mostrar que temos uma forma valida de representar pares √© verificar se as fun√ß√µes satisfazem a condi√ß√£o acima</p>

<p>O ponto sutil que deve ser notado √© que o valor retornado pela fun√ß√£o <code class="language-plaintext highlighter-rouge">(cons x y)</code> √© uma fun√ß√£o <code class="language-plaintext highlighter-rouge">dispatch</code>, que recebe um argumento e retorna $x$ ou $y$ dependendo se o argumento recebido for $0$ ou $1$. Correspondente, <code class="language-plaintext highlighter-rouge">(car z</code>) √© definida para aplicar $z$ a $0$</p>

<p>Portanto, se $z$ for a fun√ß√£o formada por <code class="language-plaintext highlighter-rouge">(cons x y)</code>, ent√£o $z$ ser√° aplicado a $0$ e ir√° resultar em $x$. Assim, n√≥s mostramos que (<code class="language-plaintext highlighter-rouge">car (cons x y))</code> resulta em $x$, conforme o desejado. De maneira similar, <code class="language-plaintext highlighter-rouge">(cdr (cons x y))</code> aplica a fun√ß√£o retornada por <code class="language-plaintext highlighter-rouge">(cons x y)</code> em $1$, que por sua vez ir√° retornar $y$. Portanto, essa implementa√ß√£o procedural de pares √© uma implementa√ß√£o v√°lida, e se caso n√≥s gostar√≠amos de ter acesso ao par usando apenas cons, car e cdr, n√≥s n√£o conseguir√≠amos distinguir essa implementa√ß√£o de alguma que use estruturas de dados ‚Äúreais‚Äù</p>

<p>A ideia de exibir esta representa√ß√£o procedural de pares n√£o √© dizer que nossa linguagem funciona dessa forma (Scheme e Sistemas Lisp em geral implementam pares de forma direta, por uma quest√£o de efici√™ncia) mas sim demonstrar que poderia funcionar desta forma. A representa√ß√£o procedural, mesmo que obscura, √© perfeitamente adequada para representar pares, desde que satisfa√ßa a condi√ß√£o que √© necess√°ria ser satisfeita.</p>

<p>Esse exemplo tamb√©m demonstra que habilidade de manipular fun√ß√µes como objetos  automaticamente prov√™ a habilidade de representar dados compostos. Isso pode parecer apenas um detalhe agora, por√©m representa√ß√µes procedurais de dados ir√£o desempenhar um papel central no nosso repert√≥rio de programa√ß√£o. Esse estilo de programa√ß√£o √© √°s vezes chamado de <em>message passing</em>, e n√≥s iremos utiliz√°-lo como ferramenta b√°sica no futuro</p>

<hr />

<h2 id="exerc√≠cios">Exerc√≠cios</h2>

<blockquote>
  <p><strong>Exercise 2.4</strong>: Here is an alternative procedural representation of pairs. For this representation, verify that (car (cons x y)) yields x for any objects x and y.</p>
</blockquote>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> 
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">m</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">z</span><span class="p">)</span> 
  <span class="p">(</span><span class="nf">z</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">q</span><span class="p">)</span> <span class="nv">p</span><span class="p">)))</span>
</code></pre></div></div>

<blockquote>
  <p>What is the corresponding definition of cdr? (Hint: To verify that this works, make use of the substitution model of 1.1.5.)</p>
</blockquote>

<ul>
  <li>
    <p><strong>Resposta</strong></p>

    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">m</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">z</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">z</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">q</span><span class="p">)</span> <span class="nv">p</span><span class="p">)))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">z</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">z</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">q</span><span class="p">)</span> <span class="nv">q</span><span class="p">)))</span>
</code></pre></div>    </div>

    <p>M√©todo de Substitui√ß√£o:</p>

    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">m</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span> <span class="c1">;; Substituimos *cons*</span>
  <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">q</span><span class="p">)</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">m</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">;; Substituimos *car*</span>
  <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">q</span><span class="p">)</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="c1">;; lambda (p q) recebe x y de lambda (m)</span>
  <span class="nv">x</span> <span class="c1">;; lambda (p q) retorna x</span>

  <span class="c1">;; Processo segue a mesma l√≥gica pra *cdr*</span>

  <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">m</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">q</span><span class="p">)</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">m</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">q</span><span class="p">)</span> <span class="nv">q</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="nv">y</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><strong>Exercise 2.5:</strong> Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair a and b as the integer that is the product 2 a 3 b . Give the corresponding definitions of the procedures cons, car, and cdr.</p>
</blockquote>

<ul>
  <li>
    <p><strong>Resposta</strong></p>

    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">;; N√£o terminado</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><strong>Exercise 2.6</strong>: In case representing pairs as procedures wasn‚Äôt mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as</p>
</blockquote>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">zero</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-1</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">n</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))))</span>
</code></pre></div></div>

<blockquote>
  <p>This representation is known as <em>Church numerals</em>, after its inventor, Alonzo Church, the logician who invented the Œª-calculus.
Define one and two directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate (add-1 zero)). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).</p>
</blockquote>

<ul>
  <li>
    <p><strong>Resposta</strong></p>

    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">#</span><span class="nv">lang</span> <span class="nv">racket</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">zero</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-1</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">n</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))))</span>

  <span class="p">(</span><span class="nf">add-1</span> <span class="nv">zero</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">add-1</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">n</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))))</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">one</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>

  <span class="p">(</span><span class="nf">add-1</span> <span class="nv">one</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">add-1</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))))</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)))))</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">two</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))))))</span>
</code></pre></div>    </div>
  </li>
</ul>
:ET